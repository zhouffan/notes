### 1、概念

[Typora添加数学公式](https://blog.csdn.net/mingzhuo_126/article/details/82722455)



**数据结构**就是指一组数据的存储结构。**算法**就是操作数据的一组方法

数据结构是为算法服务的，算法要作用在特定的数据结构之上。

10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。



T(n) = (2n2+2n+3)*unit_time

大 O 时间复杂度表示法： T(n) = O(2n2+2n+3)  

渐进时间复杂度（代码执行时间随数据规模增长的变化趋势）



1. 只关注循环执行次数最多的一段代码

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   T1(n)=O(f(n))，T2(n)=O(g(n))；

   那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

   T1(n)=O(f(n))，T2(n)=O(g(n))；

   那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

多项式量级：

O(2n) 

 O(n!)

非多项式量级：

1. O(1)：时间不随 n 的增大而增长。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

2. O(logn)、O(nlogn)：对数阶/线性对数阶

   ```java
    i=1;
    while (i <= n)  {
      //每次乘以2
      i = i * 2;
    }
   ```

   每次乘以2，2的多少次方 等于 n， 求出多少（
   $$
   2^x=n
   $$
   ）
   $$
   x=\log_2n
   $$

   $$
   \log_3n = \log_32 * \log_2n
   $$

   O(log3n) = O(C * log2n)

   即 O(Cf(n)) = O(f(n))。

   所以，O(log2n) 就等于 O(log3n).

   忽略对数的“底”，统一表示为 O(logn)。

   

3. O(m+n)、O(m*n)

   ```
   int cal(int m, int n) {
     int sum_1 = 0;
     int i = 1;
     for (; i < m; ++i) {
       sum_1 = sum_1 + i;
     }
   
     int sum_2 = 0;
     int j = 1;
     for (; j < n; ++j) {
       sum_2 = sum_2 + j;
     }
   
     return sum_1 + sum_2;
   }
   ```

   无法事先评估 m 和 n 谁的量级大，时间复杂度就是 O(m+n)

   T1(m) + T2(n) = O(f(m) + g(n))。

   但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))



**空间复杂度分析**：算法的存储空间与数据规模之间的增长关系。

O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。



最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度。

```java
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break; //加入此行，则有最好、最差
    }
  }
  return pos;
}
```









### 2、基础

#### 2.1数组

数组（Array）：是一种线性表数据结构。它用一组**连续的**内存空间，来存储一组具有**相同类型**的数据。

**线性表**（Linear List）。顾名思义，线性表就是数据排成**像一条线**一样的结构。每个线性表上的数据最多只有**前和后**两个方向。其实除了**数组，链表、队列、栈**等也是线性表结构。

**非线性表**，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

`连续的内存空间`和`相同类型`的数据。这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了**保证连续性**，就需要做大量的**数据搬移**工作。

> 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：
>
> a[i]_address = base_address + i * data_type_size
>
> data_type_size 表示数组中每个元素的大小。数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节

> 这里我要特别纠正一个“错误”。我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。
>
> 实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

**插入操作：** 需要移动其他下标数据

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？

如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 **(1+2+…n)/n=O(n)**。

还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。

在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到

**删除操作：**为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是**记录**数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。  （这不就是 JVM 标记清除垃圾回收算法的核心思想吗？）

**性能：数组就会优于容器**

寻址公式：

从0开始： a[k]_address = base_address + k * type_size

从1开始： a[k]_address = base_address + (k-1)*type_size

下标从0开始原因：会多一次计算。及历史原因。



#### 2.2链表

**缓存淘汰的常见**策略有三种：

先进先出策略 FIFO（First In，First Out）、

最少使用策略 LFU（Least Frequently Used）、

最近最少使用策略 LRU（Least Recently Used）。



数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当`内存中没有连续的、足够大的存储空间`时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。

而链表恰恰相反，它并不需要一块连续的内存空间，它通过`“指针”将一组零散的内存块串联起来`使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。

数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。时间复杂度是 O(1)。

> 链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。
>
> 寻址公式：a[k]_address = base_address + k * type_size

双向链表可以支持 O(1) 时间复杂度的情况下找到**前驱结点**，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效

不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。









 
